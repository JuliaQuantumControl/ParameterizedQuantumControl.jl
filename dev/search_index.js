var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. Machnes, E. Assémat, D. Tannor and F. K. Wilhelm. Tunable, Flexible, and Efficient Optimization of Control Pulses for Practical Qubits. Phys. Rev. Lett. 120, 150401 (2018).\n\n\n\nT. Caneva, T. Calarco and S. Montangero. Chopped random-basis quantum optimization. Phys. Rev. A 84, 022326 (2011).\n\n\n\n","category":"page"},{"location":"api/","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [ParameterizedQuantumControl]","category":"page"},{"location":"api/#ParameterizedQuantumControl.ParameterizedOptResult","page":"API","title":"ParameterizedQuantumControl.ParameterizedOptResult","text":"Result object returned by optimize_parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParameterizedQuantumControl.ParameterizedOptWrk","page":"API","title":"ParameterizedQuantumControl.ParameterizedOptWrk","text":"Parameterized Optimization Workspace.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParameterizedQuantumControl.optimize_parameters-Tuple{Any}","page":"API","title":"ParameterizedQuantumControl.optimize_parameters","text":"using ParameterizedQuantumControl\nresult = optimize(problem; method=ParameterizedQuantumControl, kwargs...)\n\noptimizes the given control problem by varying a set of control parameters in order to minimize the functional\n\nJ(u_n) = J_T(ϕ_k(T))\n\nwhere ϕ_k(T) is the result of propagating the initial state of the k'th trajectory under the parameters u_n\n\nReturns a ParameterizedOptResult.\n\nKeyword arguments that control the optimization are taken from the keyword arguments used in the instantiation of problem; any of these can be overridden with explicit keyword arguments to optimize.\n\nRequired problem keyword arguments\n\nbackend: A package to perform the optimization, e.g., Optimization (for Optimization.jl)\noptimizer: A backend-specific object to perform the optimizatino, e.g., NLopt.LN_NELDERMEAD() from NLOpt/OptimizationNLOpt\nJ_T: A function J_T(ϕ, trajectories; τ=τ) that evaluates the final time functional from a vector ϕ of forward-propagated states and problem.trajectories. For all trajectories that define a target_state, the element τₖ of the vector τ will contain the overlap of the state ϕₖ with the target_state of the k'th trajectory, or NaN otherwise.\n\nOptional problem keyword arguments\n\nparameters: An AbstractVector of parameters to tune in the optimization. By default, parameters=get_parameters(problem). If given explicitly, the vector must alias values inside the generators used in problem.trajectories so that mutating the parameters array directly affects any subsequent propagation.\nlb: An AbstractVector of lower bound values for a box constraint. Must be a vector similar to (and of the same size as parameters)\nub: An AbstractVector of upper bound values for a box constraint, cf. lb\nuse_threads: If given a true, propagate trajectories in parallel\niter_stop: The maximum number of iterations\n\n\n\n\n\n","category":"method"},{"location":"api/#ParameterizedQuantumControl.print_table-Tuple{Any, Any, Vararg{Any}}","page":"API","title":"ParameterizedQuantumControl.print_table","text":"Print optimization progress as a table.\n\nThis functions serves as the default info_hook for an optimization with ParameterizedQuantumControl.\n\n\n\n\n\n","category":"method"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/#Control-Parameters","page":"Overview","title":"Control Parameters","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The ParameterizedQuantumControl package optimizes a set u_n of arbitrary control parameters associated with a given control problem. The dynamic generators OpH = OpH(u_n t) from the different trajectories implicitly depend on these parameter values in arbitrary ways.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Contrast this with the form","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"OpH = OpH_0 + sum_l OpH_l(ϵ_l(t) t)\nquadtextorquad\nOpH_0 + sum_l a_l(ϵ_l(t) t) OpH_l\nquadtextorquad\nOpH_0 + sum_l ϵ_l(t) OpH_l","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"of a Generator, where OpH_0 is the drift term, OpH_l are the control terms, and a_l(t) and ϵ_l(t) are the control amplitudes and control functions, respectively. Methods such as GRAPE and Krotov's method optimize each ϵ_l(t) as a time-continuous function.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Control amplitudes or control functions still play a conceptual role: Even though in the most general case, the generator OpH can directly depend on the parameters, the most common case is for that dependency to be inside of the controls, ϵ_l(t)  ϵ_l(u_n t). The crucial difference is that in ParameterizedQuantumControl, we solve the optimization problem by tuning the values u_n, not ϵ_l(t) as arbitrary time-continuous control functions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The ParameterizedQuantumControl package evaluates an arbitrary optimization functional J(u_n) and optionally the gradient fracJ u_n and feeds that information to an optimization backend, e.g. Optimization.jl with its large collection of solvers. We may again contrast this with GRAPE and Krotov's method which conceptually optimize time-continuous control functions ϵ_l(t) but in practice discretize these functions as piecewise-constant on a time grid. One might be tempted to think if this discretization as the use of control parameters ϵ_l(t) = ϵ_l(ϵ_nl) where each parameter ϵ_nl is the amplitude of ϵ_l(t) on the n'th interval of the time grid (what we refer to as a \"pulse\"). However, GRAPE and Krotov have a specific numerical scheme to evaluate the gradients of the optimization functional with respect to the pulse values. That scheme is dramatically more efficient than the more general scheme to determine gradients with respect to arbitrary parameters that is used in ParameterizedQuantumControl.","category":"page"},{"location":"overview/#Parameter-API","page":"Overview","title":"Parameter API","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"ParameterizedQuantumControl manages the evaluation of functionals and gradients, and organizes feeding that information into an optimization backend. However, the structures for working with control parameters are already provided by the QuantumPropagators and QuantumControl packages. We summarize them here in the context of optimal control.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Generally, the vector of parameters is obtained from problem via the get_parameters function. This delegates to get_parameters(traj) for each Trajectory in problem.trajectories, which in turn delegates to get_parameters(traj.generator). This makes it possible to define a custom datatype for the dynamic generator for which a get_parameters method is defined. It is recommended for get_parameters to return a ComponentArrays.ComponentVector parameters. That makes it easy to keep track of which value is which parameters. However, in general, get_parameters can return an arbitrary AbstractVector. What is important is that the returned parameters alias into the generator. That is, mutating parameters and then calling QuantumControl.Controls.evaluate(generator, args...; kwargs...) must return an operator that takes into account the current values in parameters. The easiest way to achieve this is to have parameters be a field in the custom struct of the generator and have get_parameters return a reference to that field. The QuantumControl.Interfaces.check_parameterized function of QuantumControl.Interfaces.check_generator with for_parameterization=true can be used to verify the implementation of a custom generator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"As soon as we figure out the interface for the gradients, `QuantumControl.Interfaces.check_generator` needs to be implemented separately from the version in `QuantumPropagators`, and then we can properly link the above references","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"When there are multiple trajectories (and thus multiple generators) in the ControlProblem, these are automatically combined into a RecursiveArrayTools.ArrayPartition. The parameters from different generators are considered independent unless they are the same object.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"When using a built-in QuantumControl.Generators.Generator as returned by QuantumControl.hamiltonian or QuantumControl.liouvillian, the get_parameters function delegates to the get_parameters(control) for any control returned by get_controls(generator). The recommended way to implement a custom parameterized control is to subtype QuantumControl.Controls.ParameterizedFunction. Just like parameters from different generators in the same control problem are automatically combined, the parameters from different controls are also automatically combined into a RecursiveArrayTools.ArrayPartition, taking into account if get_parameters returns the same object for two different controls. In any case, for any custom implementation of a parameterized system, and especially if control parameters are aliased between different components of the system, it is important to carefully check that the result of get_parameters contains all the independent parameters of the problem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The is a connection to be made with the `parameters` field of a propagator and the paremters of the dynamic generators for the propagation.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Explain pulse parameterization","category":"page"},{"location":"overview/#Evaluation-of-the-Functional","page":"Overview","title":"Evaluation of the Functional","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"In order to evaluate an optimization functional J(u_n), the ParameterizedQuantumControl package simply uses QuantumControl.propagate_trajectories and passes the resulting states to a J_T function. Running costs are a work in progress. Again, the dynamic generators are assumed to have been implemented in such a way that mutating the values in the array returned by get_parameters are automatically taken into account.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"In principle, any propagation method can be used for the evaluation of the functional. However, parameterized controls are typically time-continuous functions, and using piecewise-constant propagators such as ExpProp, Cheby, or Newton is unnecessary and introduces a discretization error. Usually, using an ODE solver with method=OrdinaryDiffEq is more appropriate.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"It is also worth noting that the time discretization that happens in piecewise-constant propagators severs the connection between the control parameters and the pulse amplitudes at each interval of the time grid. Thus, any changes to the parameters after QuantumControl.init_prop will not be reflected in subsequent calls to QuantumControl.prop_step!. This is not an issue inside of ParameterizedQuantumControl, as QuantumControl.propagate_trajectories initializes a new propagator for every evaluation of the functional.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"* Can we guarantee that the `OrdinaryDiffEq` propagator is reusable?\n* Test that reinit_prop! updates the parameters","category":"page"},{"location":"overview/#gradients","page":"Overview","title":"Gradient Evaluation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Optimizers that rely on gradient information will be supported in a future release.","category":"page"},{"location":"overview/#Running-costs","page":"Overview","title":"Running costs","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Running costs are planned in a future release.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ParameterizedQuantumControl","category":"page"},{"location":"#ParameterizedQuantumControl.jl","page":"Home","title":"ParameterizedQuantumControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nusing Pkg\n\nVERSION = Pkg.dependencies()[Base.UUID(\"409be4c9-afa4-4246-894e-472b92a1ed06\")].version\n\ngithub_badge = \"[![Github](https://img.shields.io/badge/JuliaQuantumControl-ParameterizedQuantumControl.jl-blue.svg?logo=github)](https://github.com/JuliaQuantumControl/ParameterizedQuantumControl.jl)\"\n\nversion_badge = \"![v$VERSION](https://img.shields.io/badge/version-v$(replace(string(VERSION), \"-\" => \"--\"))-green.svg)\"\n\nMarkdown.parse(\"$github_badge $version_badge\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implementation of control methods for analytical parameterized control fields.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Part of QuantumControl.jl and the JuliaQuantumControl organization.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As usual, the package can be installed with","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ParameterizedQuantumControl","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Define a QuantumControl.ControlProblem that contains parameterized generators or control fields: get_parameters(problem) must return a vector of control parameters.\nCall QuantumControl.optimize using method=ParameterizedQuantumControl, and give an appropriate backend and optimizer, e.g.,\noptimize(\n    problem;\n    method=ParameterizedQuantumControl,\n    backend=Optimization,\n    optimizer=NLopt.LN_NELDERMEAD(),\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See ParameterizedQuantumControl.optimize_parameters for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, only Optimization.jl is supported as a backend, and only with gradient-free optimizers. In the future, this will be extended to gradient-based optimizers (i.e., the \"GOAT\" method [1]), as well as specific pulse parametrizations (e.g., CRAB [2]).","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 2\nPages = [pair[2] for pair in Main.PAGES[2:end-1]]","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Releases on Github.","category":"page"}]
}
